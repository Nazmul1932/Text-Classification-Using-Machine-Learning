# -*- coding: utf-8 -*-
"""Text Sentimant Using Machine Learning.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11UQKYKq30qUiO9jUqMqP1ETQ7nIFNSr6
"""

class Sentiment:
    Negative = "Negative"
    Neutral = "Neutral"
    Positive = "Positive"

class Review:
  def __init__(self, text, score):
    self.text = text
    self.score = score
    self.sentiment = self.get_sentiment() 
  
  def get_sentiment(self):
    if self.score <= 2:
        return Sentiment.Negative
    elif self.score == 3:
        return Sentiment.Neutral
    else:
        return Sentiment.Positive

import random

class ReviewContainer:
    def __init__(self, reviews):
        self.reviews = reviews
    
    def get_text(self):
        return [x.text for x in self.reviews]
    
    def get_sentiment(self):
        return [x.sentiment for x in self.reviews]

    def evenly_distribute(self):
        negative = list(filter(lambda x: x.sentiment == Sentiment.Negative, self.reviews))
        positive = list(filter(lambda x: x.sentiment == Sentiment.Positive, self.reviews))
        positive_shrunk = positive[: len(negative)]
        self.reviews = negative + positive_shrunk
        random.shuffle(self.reviews)

import json
file_name = 'Books_small.json'

reviews = []

with open(file_name) as f:
  for line in f:
    review = json.loads(line)
    reviews.append(Review(review['reviewText'],review['overall']))
reviews[6].sentiment

from sklearn.model_selection import train_test_split

train, test = train_test_split(reviews, test_size=0.4, random_state=42)

train_container = ReviewContainer(train)
test_container = ReviewContainer(test)

len(cont.reviews)

print(train[0].text)
print(train[0].sentiment)
print(test[0].text)
print(test[0].sentiment)

train_container.evenly_distribute()

train_text = train_container.get_text()
train_sentiment = train_container.get_sentiment()

test_container.evenly_distribute()
test_text = test_container.get_text()
test_sentiment = test_container.get_sentiment()

print(train_sentiment.count(Sentiment.Negative))
print(train_sentiment.count(Sentiment.Positive))

from sklearn.feature_extraction.text import CountVectorizer, TfidfVectorizer

vectorizer = TfidfVectorizer()
train_text_vectors = vectorizer.fit_transform(train_text)
test_text_vectors = vectorizer.transform(test_text)

from sklearn import svm

clf_svm = svm.SVC(kernel='linear')
clf_svm.fit(train_text_vectors, train_sentiment)
test_text[0]
clf_svm.predict(test_text_vectors[0])

from sklearn.tree import DecisionTreeClassifier

clf_dec = DecisionTreeClassifier()
clf_dec.fit(train_text_vectors, train_sentiment)

clf_dec.predict(test_text_vectors[0])

!pip install sklearn

from sklearn.naive_bayes import GaussianNB

clf_gnb = DecisionTreeClassifier()
clf_gnb.fit(train_text_vectors, train_sentiment)

clf_gnb.predict(test_text_vectors[0])

from sklearn.linear_model import LogisticRegression

clf_log = LogisticRegression()
clf_log.fit(train_text_vectors, train_sentiment)

clf_log.predict(test_text_vectors[0])

print(clf_svm.score(test_text_vectors, test_sentiment))
print(clf_dec.score(test_text_vectors, test_sentiment))
print(clf_gnb.score(test_text_vectors, test_sentiment))
print(clf_log.score(test_text_vectors, test_sentiment))

from sklearn.metrics import f1_score
f1_score(test_sentiment, clf_svm.predict(test_text_vectors), average=None, 
        labels=[Sentiment.Positive, Sentiment.Negative, Sentiment.Neutral])

train_sentiment[0:5]

train_sentiment.count(Sentiment.Positive)

train_sentiment.count(Sentiment.Negative)

train_sentiment.count(Sentiment.Neutral)

test_sentiment.count(Sentiment.Negative)

test_set = ['very fun', "bad book do not buy", 'horrible waste of time']
new_test = vectorizer.transform(test_set)
clf_svm.predict(new_test)

from sklearn.model_selection import GridSearchCV

parameters = {'kernel': ('linear','rbf'), 'C':(1,4,8,16,32)}

svc = svm.SVC()

clf = GridSearchCV(svc, parameters, cv=5)

clf.fit(train_text_vectors, train_sentiment)

print(clf.score(test_text_vectors, test_sentiment))

import pickle

with open('sentiment_classifier.pkl', 'wb') as f:
    pickle.dump(clf, f)

with open('sentiment_classifier.pkl', 'rb') as f:
    loaded_clf = pickle.load(f)

print(test_text[0])

loaded_clf.predict(test_text_vectors[0])

